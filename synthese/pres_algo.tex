Au cours de cette partie l'algorithme de préflot générique sera étudié et sa validité sera
démontrée, deux autres algorithmes (FIFO et high label) très similaires au générique seront
présentés et puisque ces derniers ne sont qu'une amélioration de l'algorithme générique, leur
validité découlera de la validité de ce dernier.

Les calculs de complexité seront développés dans la partie suivante.

\section{L'algorithme Générique}

\subsection{Principe}

L'algorithme générique repose sur les principes suivants :
\begin{enumerate}
	\item une action locale
	\item l'utilisation de la relaxation de contrainte des préflots
	\item une fonction de distance
\end{enumerate}

D'une façon imagée, assimilons le graphe à un réseau de tuyaux de capacité donnée, les sommets à des
réservoirs pouvant accumuler une quantité infinie de préflot et étant caractérisés par leur distance au
puits. Le but de la manoeuvre étant d'acheminer une quantité maximale de flot de la source vers le
puits à l'aide du réseau fourni. Pour des raisons de commodité, la distance du n\oe ud source est fixée
au nombre de sommets dans le réseau. 

Intuitivement, il est facile de comprendre que, pour que le préflot aille de la source vers le puits,
celui ci doit transiter d'un réservoir $a$ vers un réservoir $b$ satisfaisant la condition suivante:
\emph{La distance de $a$ au puits doit être supérieure à la distance de $b$.} Ceci indique que le
n\oe ud cherchant à pousser est plus loin de $t$ que le n\oe ud cible.  En imaginant que l'on
fasse le contraire, le préflot resterait cantonné à sa source sans même entrer dans le réseau défini
par le graphe. L'action de faire transiter le préflot d'un n\oe ud $a$ à un n\oe ud $b$ est appelée
opération de \emph{poussage}.

Au moment ou un n\oe ud $a$ reçoit une quantité de préflot de l'un de ses voisins $b$ ayant réalisé une
opération de poussage, la quantité de préflot envoyée de $b$ vers $a$ est alors directement stockée
dans $a$, s'ajoutant ainsi à la quantité de flot déjà stockée. Cette dernière sera appelée
\emph{excédent du sommet $a$} et notée $e$. À un moment donné, si, pour un n\oe ud quelconque $a$,
$e(a) > 0$, alors $a$ sera dit excédentaire.

Seulement, l'opération de poussage à elle seule ne permets pas d'obtenir un flot satisfaisant.
Ceci est illustré par l'exemple de la figure \ref{ex_pouss} : après la phase 2, le n\oe ud $1$ est
encore débordant mais il lui est impossible d'effectuer une opération de poussage puisque l'arête
le reliant à $t$ est saturée et $s$ et $2$ ont une distance au n\oe ud puits supérieure ou égale à
celle de $1$. Il faut donc introduire une opération supplémentaire, appelée ré-étiquetage.

\begin{figure}
	\begin{center}
		\begin{tikzpicture}[node distance=0.5cm]
			\tikzset{noeud/.style={circle, draw=black, minimum size=17pt, inner sep=1pt},
			fleche/.style={->,>=latex,thick}};


			\foreach \y/\f/\fl/\flo/\flot/\e/\ex/\text/\excd in {0/0/0/0/0/0/0/Initialisation/0,
				5/10/0/0/0/10/0/Phase 1/0, 10/10/0/0/9/1/0/Phase 2/9}{
					\node at (0, -1 * \y + 1) {\underline{\text}};
			\foreach \name/\x/\exc\dist in {s/0/0/4, 1/3/\e/1, 2/6/\ex/1, t/9/\excd/0}{
				\node[noeud] (\y-\name) at (\x, -1 * \y) {$\name$};
				\node (\y-e-\name) at (\x, -1 - \y ) {$e=\exc$};
				\node (\y-d-\name) [below of=\y-e-\name] {$d=\dist$};
			}

			\draw[fleche] (\y-s) -- node[above] {$f=  \f$} node[below] {$c=10$} (\y-1);
			\draw[fleche] (\y-1) -- node[above] {$f= \fl$} node[below] {$c=12$} (\y-2);
			\draw[fleche] (\y-2) -- node[above] {$f=\flo$} node[below] {$c= 1$} (\y-t);
			\draw[fleche] (\y-1) to[out=45, in=135]	node[above] {$f=\flot$} node[below] {$c= 9$} (\y-t);
		}

		\end{tikzpicture}
	\end{center}
	\caption{Exécution d'un algorithme n'utilisant que les méthodes de poussage}
	\label{ex_pouss}
\end{figure}

Le ré-étiquetage consiste à réévaluer la distance du n\oe ud débordant au n\oe ud puits de façon à ce
qu'il soit possible, après cette opération, d'effectuer une opération de poussage depuis ce n\oe ud.
Soit un n\oe ud excédentaire $i$ de distance $d_i$ et son $v_i$ son voisinage de sorte que $\forall v
\in v_i$, on a : $d_v \geq d_i$. La distance de $i$ doit être réévaluée afin de pouvoir évacuer
l'excédent de flot, il faut donc augmenter $d_i$ jusqu'à ce qu'un poussage puisse être réalisé ce
qui revient à fixer $d_i = 1 + \min(d_v), \quad v \in v_i$. 

L'algorithme générique se résume en deux étapes qui sont la procédure d'initialisation qui permet de
fournir une fonction de distance valide et de créer les premiers n\oe uds actifs en saturant les
arcs sortant de $s$ et une boucle agissant sur les n\oe uds débordants par poussage ou réétiquetage.

\input{gen.tex}
\input{initialisation.tex}

La procédure Pousser-Réétiqueter appelle à quelques explications. La variable $p$ est un booléen
permettant de déterminer si l'algorithme a effectué une opération de poussage, si ce n'est pas la
cas, la procédure effectue un réétiquetage. La variable $f$ quant à elle permet de déterminer s'il
s'agit là de la première itération, afin de pouvoir initialiser correctement $m$ (qui est utilisé
pour rechercher le plus petit des voisins du n\oe ud effectuant l'algorithme).

\input{pousser.tex}

Il sera démontré plus loin que cet algorithme s'exécute en $O(n^2m)$.

\subsection{Validité}

Pour montrer que l'algorithme de préflot-générique résout le probléme du flot maximum, Nous allons démonter que s'il se termine, Alors le préflot $f$ calculé est un flot maximum!.\\

\textbf{Passage par les opérations de poussage et réétiquetage:}  
\begin{lemma} ~\\
	\label{increase_distance}Soit $G$ $=$($S$,$A$) un réseau de transport de source $s$ et puits $t$, soit $f$ un préflot et 
  soit $d$ une fonction  de distance  pour $f$. si $u$ est un sommet débordant, alors on peut lui appliquer soit un poussage, soit un réétiquetage  
\end{lemma}   
\textbf{Preuve} \\
soit ($u$,$v$) un arc résiduel quelconque, donc on a $d(u)\leq d(v)+$1. car $d$ est une fonction  de distance .  Si une opération de poussage ne peut pas appliquer à $u$, alors pour tous les arcs résiduels($u$,$v$),on doit avoir $d$($u$)$<$ $d$($v$)$+$1, ce qui implique que $d$($u$)$\leq$ $d$($v$). Donc une opération de réétiquetage peut être appliqué à $u$.\\                        

$***$ Opération poussage:
D'après la procédure de poussage dans ce qui précéde on peut conclure que
si $f$ est un préflot avant que la procédure de poussage soit appelée, il reste un préflot après.\\

\textbf{Retour à $d$ la fonction de distance:}\\
\begin{lemma} ~\\
	\label{residual_path}Durrant l'exécution de l'algorithme de préflot-générique sur $G$ un réseau de transport de source $s$ et puits $t$. la fonction $d$ reste toujours une fonction de distance
\end{lemma}  
\textbf{Preuve} \\
  On raisone par récurence sur le nombre d'opérations élémentaires éffectuées.
  Après l'initialisation au départ, il est vrai que $d$ est une fonction de distance.\\
  
  A-en réétiqutage:
  Comme nous l'avons déjà vu.
  On assure que si $d$ est une fonction de distance, alors elle la restera après une opération de réétiquetage de $u$.
  Prenons un arc résiduel ($u$,$v$)$\in$ $A_f$  sortant du sommet $u$.
  Alors l'opération réétiqueter($u$) nous garantit la contrainte suivante:
  $d$($u$)$\leq$ $d$($v$)$+$1 après.
  Prenons maintenant un autre arc ($w$,$u$) entrant au sommet $u$. alors on a d'après lemme5.0.1(vu en partie Complexité) que $d$($w$)$\leq$ $d$($u$)$+$1 avant le réétiquetage de $u$. entraîne que $d$($w$)$\leq$ $d$($u$)$+$1 après. Donc la fonction $d$ reste toujours une fonction de distance après l'opération réétiquetage\\
  
  B-en poussage:
  L'opération poussage($u$,$v$), soit elle ajoutera l'arc ($v$,$u$)$\in$ $A_f$, soit supprimera l'arc ($u$,$v$) de $A_f$. alors dans le cas d'ajout, on a $d$($v$)$=$ $d$($u$)$-$1 $<$ $d$($u$)$+$1 ce qui implique que $d$ reste une fonction de distance. dans le cas de suppression de l'arc ($u$,$v$) dans le réseau résiduel supprime le contraint correspondant et $d$ reste encore une fonction de hautaur 
 
 Conclusion:
  D'après A et B on conclut que $d$ la fonction de distance reste toujours une fonction de distance.
  \\
   
\begin{lemma} ~\\
	\label{borne_reetiq}Soit $G$ $=$($S$,$A$) un réseau de transport de source $s$ et puits $t$ soit $f$ un préflot de $G$ et $d$ une fonction de distance sur $A$, alors il n'existe aucun chemin allant de la source $s$ au puits $t$ dans le réseau résiduel $G_f$.
\end{lemma} 

\textbf{Preuve} \\
Supposons le contraire, c'est-à-dire qu'il existe un chemin élémentaire $µ$ $=$\{$v_0$,....,$v_k$\} avec $v_0$ $=$ $s$ et $v_k$ $=$ $t$ de $s$ vers $t$ dans $G_f$.
$µ$ élémentaire donc $k$ $<$ $|$ $s$ $|$
Soit $i$ $=$\{0,1,...,$k$ $-$1\}, l'arc ($v_i$,$v_{i+1}$)$\in$ $A_f$. Comme $d$ est une fonction de distance $d$($v_i$)$\leq$ $d$($v_{i+1}$)$+$1 encore pour $i$ $=$\{0,1,...,$k$ $-$1\}, en appliquant ces inégalités sur tout le chemin $µ$, on aura
$d$($s$)$\leq$ $d$($t$)$+$ $k$. Mais comme $d$($v_k$)$=$ $d$($t$)$=$0, on obtient 
$d$($s$)$=$ $k$ $<$ $|$ $s$ $|$, ce qui conterdit la contrainte $d$($s$)$=$ $|$ $s$ $|$ pour une fonction de distance \\

\begin{thrm}
Si l'algorithme de préflot se termine, Alors le préflot $f$ calculé est un flot maximum.
\end{thrm}

\textbf{Preuve} \\
 Regardons la boucle 'Tant que' dans l'algorithme préflot-générique A chaque exécution de test de cette boucle, $f$ est un préflot.
 
 \textbf{Initialisation:}Initialiser-préflot fait de $f$ est un préflot.\\ 
 
 \textbf{Conservation:}Les seules opérations faites dans la boucle 'tant que' sont soit l'opération de poussage, ou celui de réétiquetage.  
 L'opération de réétiquetage appliquée uniquement sur les distances des sommets, c'est-à-dire pas la valeur du flot, Alors elle ne distingue pas que si $f$ un préflot ou non, après ($***$) on a que si $f$ est un préflot avant poussage, il reste un préflot après.\\

 
 \textbf{Terminaison:}A la fin de l'exécution de l'algorithme, chaque sommet de
$S$-\{$s$,$t$\} doit avoir un excédent vaut 0, en effet d'après le lemme3.2.1 et le lemme3.2.2 et l'invariant selon lequel $f$ est toujours un préflot, Il n'y a pas de sommet débordant, par conséquent $f$ est un préflot. comme $d$ est une fonction de distance le lemme3.2.3 nous dit qu'il n'y a pas de chemin entre la source $s$ et le puits $t$ dans le réseau résiduel $G_f$.
 Alors après le théorème du flot maximum et la coupe minimum le préflot $f$ calculé est un flot maximum.  


\section{Les algorithmes dérivés}

Nous présenterons dans cette section, les différents algorithmes reposant sur l'algorithme générique
présenté précédemment. Pour la totalité d'entre eux, il s'agit de chercher à réaliser un choix
judicieux pour l'examen des n\oe uds débordants.

\subsection{L'algorithme FIFO}

L'algorithme FIFO, utilise une file afin de gérer l'ordre des n\oe uds actifs à traiter : au moment
ou un sommet du graphe devient débordant, celui-ci est placé dans une file, dont la politique de
traitement est du type \emph{First In First Out}. 

A chaque examen, l'algorithme réalise des opérations de poussage tant que celles-ci sont possible et
tant que le n\oe ud $i$ examiné est débordant. Si, lorsqu'il n'existe plus d'arêtes acceptables,
$e(i)$ est toujours supérieur à $0$, l'algorithme réalise donc un réétiquetage et place à nouveau
$i$ dans la file des sommets à examiner. L'initialisation de l'algorithme est la procédure
principale restent les mêmes que l'algorithme générique.

Ce choix permet une amélioration de la complexité de l'agorithme générique en $O(n^3)$.

\subsection{L'algorithme High label}

Il existe des graphes pour lesquels, l'agorithme FIFO est très lent. On peut par exemple citer
celui décrit figure \ref{bad_fifo}.

\begin{figure}
\begin{center}
\begin{tikzpicture}[node distance=2.2cm]
\tikzset{n/.style={circle, draw=black, minimum size=27pt, inner sep=1pt}, 
f/.style={->, >=latex}};

\node[n] (s) at (4.4, 3) {$s$};
\node[n] (n0) at (0, 0) {$n$};
\node[n] (n1) [right of=n0] {$n-1$};
\node[right of=n1] (point) {$\cdots$};
\node[n, right of=point] (2) {$2$};
\node[n, right of=2] (1) {$1$};
\node[n, right of=1] (t) {$t$};

\foreach \x/\pos in {n0/right, n1/right, 2/left, 1/left} {
	\draw[f] (s) to node[\pos] {$1$} (\x);
}

\draw[f] (n0) to node[below] {$\infty$} (n1);
\draw[f] (n1) to node[below] {$\infty$} (point);
\draw[f] (point) to node[below] {$\infty$} (2);
\draw[f] (2) to node [below] {$\infty$} (1);
\draw[f] (1) to node [below] {$\infty$} (t);

\end{tikzpicture}
\end{center}
\caption{Exemple de graphe mettant en défaut l'algorithme FIFO}
\label{bad_fifo}
\end{figure}

En effet, lors de l'initialisation de ce dernier, les n\oe uds vont être placés en file d'attente
selon l'ordre de traitement des arêtes sortant de $s$. Si celui ci se fait par ordre
lexicographique, le sommet $1$ sera placé dans la file en premier puis le $2$ et ainsi de suite
jusqu'au sommet $n$. L'examen se fera donc dans cet ordre, on s'aperçoit alors que $1$ pousse son
excédent vers $t$, puis $2$ pousse son excédent vers $1$ et ainsi de suite jusqu'au n\oe ud $n$
poussant vers $n-1$.
Puis le traitement recommence à partir de $1$ jusque $n-1$, puis de $1$ jusque $n-2$, etc... On
dénombre alors $n!$ opérations.

Le principe de l'algorithme High Label est de choisir pour l'examen, le n\oe ud ayant la distance la
plus grande, de lui appliquer le plus grand nombre de poussage et de le réétiqueter si besoin est.
L'algorithme effectue, sur le graphe représenté figure \ref{bad_fifo}, seulement $n$ opérations.
Nous démontrerons que la complexité de cet algorithme s'en voit améliorée pour atteindre du
$O(n^2\sqrt{m})$.
